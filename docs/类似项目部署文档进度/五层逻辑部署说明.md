# AISP 五层逻辑部署说明

## 📋 概述

本文档说明AISP项目中AI启动时的五层逻辑加载机制，确保任务按照正确的逻辑顺序展开，避免破坏已有的架构与设计。

## 🏗️ 五层逻辑结构

```
                    ┌─────────────────────────┐
                    │      L1 元目标层        │
                    │   Meta Goal Layer       │
                    │                         │
                    │  定义终极目标           │
                    │  不可被覆盖             │
                    └───────────┬─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │    L2 全局理解层        │
                    │ Global Understanding    │
                    │                         │
                    │ 只做理解，不做修改       │
                    └───────────┬─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │      L3 约束层          │
                    │   Constraint Layer      │
                    │                         │
                    │ 加载所有规则和限制       │
                    └───────────┬─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │      L4 决策层          │
                    │   Decision Layer        │
                    │                         │
                    │ 做出修改决策             │
                    └───────────┬─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │      L5 执行层          │
                    │   Execution Layer       │
                    │                         │
                    │ 执行具体修改             │
                    └─────────────────────────┘
```

## 📁 文件结构

```
AISP/
├── logic_layers_deployment.json    # 五层逻辑部署配置
├── docs/
│   ├── 整体项目逻辑.md             # 项目整体逻辑说明
│   ├── 模块依赖关系.md             # 模块依赖分析
│   └── ...
└── ...
```

## 🔧 使用说明

### 1. 配置文件位置

- **主配置文件**: `AISP/logic_layers_deployment.json`
- **项目规则**: `AISP/.blackboxrules`
- **项目结构**: `AISP/directory_structure.json`

### 2. 加载顺序

必须严格按照以下顺序加载：

1. **L1 元目标层** - 加载终极目标和核心原则
2. **L2 全局理解层** - 构建项目抽象模型
3. **L3 约束层** - 加载规则和限制
4. **L4 决策层** - 做出修改决策
5. **L5 执行层** - 执行具体修改

### 3. 各层详细说明

#### L1｜元目标层（Meta Goal Layer）

**目标**: 定义执行任务的终极目标，决定"什么是正确方向"

**核心原则**:
- 保持项目结构一致性
- 保持项目逻辑一致性
- 保持项目可演化性
- 保证项目无缝扩展和维护

**约束**:
- 不允许任何具体配置覆盖元目标
- 所有后续决策必须符合元目标方向
- 禁止破坏项目整体架构的任何修改

**配置位置**: `.blackboxrules`

#### L2｜全局理解层（Global Understanding Layer）

**目标**: 只做理解，不做任何修改，构建项目抽象模型

**理解目标**:
- 项目整体结构 (`directory_structure.json`, `README.md`)
- 模块真实意图 (`gui`, `backend`, `engines`, `scripts` 等)
- 数据流向 (入口点 → 处理管道 → 输出目的地)
- 控制流 (控制中心、状态管理)

**约束**:
- 只提供"理解"，不产生任何直接的行为或修改
- 必须构建完整的抽象模型
- 输出对项目架构和需求的深度理解

**配置位置**: `docs/整体项目逻辑.md`

#### L3｜约束层（Constraint Layer）

**目标**: 加载所有项目约定与规则，确保不会违反任何约束

**约束类别**:
1. **命名约束** - Python模块snake_case、配置文件kebab-case、类名PascalCase
2. **结构约束** - GUI层禁止直接调用业务逻辑、引擎调用必须经过engine_base.py
3. **修复规则** - 重复功能必须合并、保持接口契约不变
4. **安全约束** - 敏感配置加密、API认证
5. **禁止项** - 错误命名、结构混乱、功能重复、硬编码路径

**约束等级**:
- `error`: 严重违反，不可执行
- `warning`: 建议遵守，应修复
- `info`: 推荐遵守

#### L4｜决策层（Decision Layer）

**目标**: 在理解和约束的基础上做出决策

**决策流程**:
1. **可修改性分析** - 判断哪些内容可以修改
2. **优先级确定** - 确定修改的优先级与范围
3. **冲突解决** - 解决决策冲突

**决策类型**:
- **批准** - 符合所有层级要求
- **拒绝** - 与L1冲突、破坏L2理解、违反L3约束
- **有条件修改** - 需要调整以符合约束

**决策原则**:
- L1目标优先于其他所有考量
- L2理解模型不可被破坏
- L3约束是硬性边界

#### L5｜执行层（Execution Layer）

**目标**: 在决策通过后执行具体的修改

**执行类型**:
- **代码合并** - 合并重复代码，保留最优实现
- **配置优化** - 优化配置文件
- **模块重构** - 重构模块结构
- **清理操作** - 清理冗余代码和配置

**执行约束**:
- 不能反向影响前四层的内容
- 不能破坏前层设定的方向和理解
- 必须严格遵循L4决策
- 不可以越过或推翻前四层的任何内容

## 📊 项目映射

### 模块与层级对应

| 模块 | 涉及的层级 | 角色 |
|------|-----------|------|
| `gui` | L2, L3, L5 | 用户交互层 |
| `backend` | L2, L3, L4, L5 | 核心业务逻辑层 |
| `engines` | L2, L3, L5 | 底层引擎抽象层 |
| `scripts` | L1, L3, L5 | 运维脚本层 |
| `web` | L2, L3, L5 | Web监控层 |
| `containers` | L1, L3, L5 | 容器化部署层 |
| `docs` | L2, L3, L4, L5 | 文档层 |

### 各层级对模块的处理

#### GUI层
- **L2分析**: 分析用户交互模式和界面组件关系
- **L3约束**: 命名规范、模块职责分离
- **L5执行**: 界面优化、功能扩展

#### 后端层
- **L2分析**: 分析服务层、控制核心、AI控制的交互关系
- **L3约束**: API规范、服务接口契约、状态管理规则
- **L4决策**: 决策功能修改、服务重构优先级
- **L5执行**: 服务实现、逻辑优化、bug修复

#### 引擎层
- **L2分析**: 分析引擎接口、适配器模式、数据处理流程
- **L3约束**: engine_base接口规范、适配器实现规则
- **L5执行**: 引擎适配、接口实现、性能优化

## 🔄 执行工作流

### 阶段1: 准备

```
步骤1.1 - L1元目标层
  动作: 加载元目标
  输出: 项目终极目标和核心原则

步骤1.2 - L2全局理解层
  动作: 构建项目理解
  输出: 项目抽象模型和模块关系
```

### 阶段2: 验证

```
步骤2.1 - L3约束层
  动作: 加载约束
  输出: 规则和限制集合
```

### 阶段3: 决策

```
步骤3.1 - L4决策层
  动作: 做出决策
  输出: 修改决策和优先级
```

### 阶段4: 执行

```
步骤4.1 - L5执行层
  动作: 执行修改
  输出: 修改结果和验证报告
```

### 阶段5: 验证

```
步骤5.1 - 全层级
  动作: 验证一致性
  输出: 一致性验证报告
```

## ✅ 验证规则

### 层级顺序验证

```json
{
  "required_order": ["L1", "L2", "L3", "L4", "L5"],
  "description": "必须严格按照L1->L2->L3->L4->L5顺序执行"
}
```

### 输出要求验证

| 层级 | 必须输出 |
|------|---------|
| L1 | goal_state, direction |
| L2 | understanding_state, abstract_model, dependency_map |
| L3 | constraint_set, validation_boundaries |
| L4 | decision, priority, scope, conditions |
| L5 | modified_files, changes_summary, verification_results |

### 一致性检查

1. **L4决策与L1目标一致性**
   - 验证: 决策结果不能与L1目标冲突

2. **L5执行与L2理解一致性**
   - 验证: 执行不能破坏L2构建的理解模型

3. **L4决策与L3约束一致性**
   - 验证: 决策必须遵守L3约束

4. **L5执行与L4决策一致性**
   - 验证: 执行必须严格遵循L4决策

## 📝 使用示例

### 示例1: 新功能开发

```python
# 1. 加载元目标 (L1)
goal = load_meta_goal()
assert goal.is_consistent_with_project_direction()

# 2. 构建理解 (L2)
understanding = build_project_understanding()
assert understanding.covers_new_feature_area()

# 3. 加载约束 (L3)
constraints = load_constraints()
assert constraints.allow_new_feature()

# 4. 做出决策 (L4)
decision = make_decision(
    understanding=understanding,
    constraints=constraints
)
assert decision.is_approved()

# 5. 执行开发 (L5)
execute_modification(decision)
```

### 示例2: Bug修复

```python
# 1. 加载元目标
goal = load_meta_goal()
assert goal.supports_bug_fixing()

# 2. 理解问题
understanding = analyze_bug_report()
assert understanding.identifies_root_cause()

# 3. 加载约束
constraints = load_constraints()
assert constraints.allow_code_modification()

# 4. 决策修复方案
decision = plan_fix(understanding, constraints)
assert decision.is_approved()

# 5. 执行修复
execute_fix(decision)
```

## 🔍 常见问题

### Q1: 如果L4决策被拒绝怎么办？

**A**: 如果决策被拒绝，需要:
1. 分析拒绝原因
2. 调整修改方案
3. 重新提交决策请求
4. 或放弃该修改

### Q2: 如何处理跨层级的冲突？

**A**: 按以下优先级处理:
1. L1目标 > L2理解 > L3约束 > L4决策 > L5执行
2. 低层级必须服从高层级的决定

### Q3: 是否可以跳过某个层级？

**A**: 不可以。五个层级必须严格按照顺序执行，任何跳过都会导致:
- 违反项目规则
- 可能的架构破坏
- 难以追踪的问题

## 📚 相关文档

- `logic_layers_deployment.json` - 五层逻辑部署配置
- `.blackboxrules` - AI执行规则
- `docs/整体项目逻辑.md` - 项目整体逻辑
- `docs/模块依赖关系.md` - 模块依赖分析
- `directory_structure.json` - 项目目录结构

## 📄 版本信息

- **版本**: 1.0.0
- **创建日期**: 2025-01-21
- **最后更新**: 2025-01-21
- **作者**: AISP Team

---

*本文档遵循MIT许可证*

