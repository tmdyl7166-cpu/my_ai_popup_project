# 25. 脚本重构与模块化任务

## 任务概述
根据 docs/待部署内容/6.落实代码需要优化的部分问题.txt、docs/待部署内容/针对项目必须执行的路径以及对于整体项目的联动性脚本与其他内容的关联性.txt 中的要求，对现有脚本进行拆分重构，实现高内聚、低耦合、模块化设计。每个功能拆分为独立模块，独立JS文件/独立函数模块，统一入口协调调用。

## 模块职责
- **脚本扫描模块**: 扫描并分析现有脚本，识别功能边界。
- **脚本拆分模块**: 将大脚本拆分为单一职责模块。
- **脚本合并模块**: 合并重复功能的脚本。
- **接口标准化模块**: 定义模块间标准接口。
- **统一入口模块**: 创建主控制器协调各模块调用。

## 详细部署说明

### 1. 脚本扫描与识别
1.1 扫描范围
- scripts/*.py: Python脚本
- scripts/*.sh: Shell脚本
- scripts/*/*.py: 子目录Python脚本
- scripts/core/*.py: 核心功能脚本
- scripts/deploy/*.py: 部署脚本
- scripts/health/*.py: 健康检查脚本
- scripts/utils/*.py: 工具脚本
- scripts/web/*.py: Web相关脚本
- scripts/ui/*.py: UI相关脚本

1.2 功能边界分析
- 识别每个脚本的核心功能
- 标记重复功能
- 标记跨职责功能
- 代码示例：
```python
import ast
import os
from pathlib import Path

class ScriptAnalyzer:
    """脚本分析器"""
    
    def __init__(self, scripts_dir):
        self.scripts_dir = Path(scripts_dir)
        self.script_map = {}
    
    def scan_all_scripts(self):
        """扫描所有脚本"""
        for py_file in self.scripts_dir.rglob('*.py'):
            self.analyze_script(py_file)
        for sh_file in self.scripts_dir.rglob('*.sh'):
            self.analyze_shell_script(sh_file)
    
    def analyze_script(self, file_path):
        """分析Python脚本"""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        try:
            tree = ast.parse(content)
            functions = []
            classes = []
            imports = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    functions.append(node.name)
                elif isinstance(node, ast.ClassDef):
                    classes.append(node.name)
                elif isinstance(node, ast.Import):
                    imports.extend([alias.name for alias in node.names])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.append(node.module)
            
            self.script_map[str(file_path)] = {
                'functions': functions,
                'classes': classes,
                'imports': imports,
                'size': len(content)
            }
        except SyntaxError:
            self.script_map[str(file_path)] = {
                'error': 'Syntax error',
                'size': len(content)
            }
    
    def find_duplicates(self):
        """查找重复功能"""
        duplicate_functions = {}
        for file_path, info in self.script_map.items():
            if 'error' in info:
                continue
            for func_name in info.get('functions', []):
                if func_name in duplicate_functions:
                    duplicate_functions[func_name].append(file_path)
                else:
                    duplicate_functions[func_name] = [file_path]
        
        return {k: v for k, v in duplicate_functions.items() if len(v) > 1}
```

### 2. 脚本拆分策略
2.1 拆分原则
- 每个模块只负责一个明确、单一的功能
- 不允许功能重叠
- 不允许承担业务流程控制职责
- 模块间禁止直接相互调用

2.2 拆分示例
以 scripts/health_check.py 为例：
```
health_check.py 拆分为:
- scripts/health/environment_check.py  # 环境检查
- scripts/health/dependency_check.py   # 依赖检查
- scripts/health/config_check.py       # 配置检查
- scripts/health/port_check.py         # 端口检查
- scripts/health/process_check.py      # 进程检查
- scripts/health/disk_check.py         # 磁盘检查
- scripts/health/memory_check.py       # 内存检查
- scripts/health/cpu_check.py          # CPU检查
- scripts/health/report_generator.py   # 报告生成
- scripts/health/check_coordinator.py  # 检查协调器
```

2.3 拆分代码示例
```python
# scripts/health/environment_check.py
"""环境检查模块"""
import platform

class EnvironmentChecker:
    """环境检查器"""
    
    def check_os(self) -> dict:
        """检查操作系统"""
        return {
            'system': platform.system(),
            'release': platform.release(),
            'version': platform.version(),
            'machine': platform.machine()
        }
    
    def check_python_version(self) -> dict:
        """检查Python版本"""
        import sys
        return {
            'version': sys.version,
            'version_info': sys.version_info,
            'executable': sys.executable
        }
    
    def check_all(self) -> dict:
        """检查所有环境项"""
        return {
            'os': self.check_os(),
            'python': self.check_python_version()
        }
```

### 3. 接口标准化
3.1 模块接口规范
- 每个模块必须暴露 init, update, destroy 接口
- 输入输出使用标准数据结构
- 错误处理使用统一格式
- 代码示例：
```python
# 模块接口标准
class ModuleStandard:
    """模块标准接口"""
    
    def init(self, config: dict) -> bool:
        """初始化模块
        Args:
            config: 配置字典
        Returns:
            bool: 初始化是否成功
        """
        pass
    
    def update(self, data: dict) -> dict:
        """更新模块
        Args:
            data: 输入数据
        Returns:
            dict: 输出数据
        """
        pass
    
    def destroy(self) -> bool:
        """销毁模块
        Returns:
            bool: 销毁是否成功
        """
        pass
```

3.2 数据结构标准
- 使用字典作为标准数据结构
- 定义标准错误格式
- 定义标准返回格式
- 代码示例：
```python
# 标准数据结构
STANDARD_RESPONSE = {
    'status': 'success' | 'error',
    'data': {},
    'error': {
        'code': int,
        'message': str
    },
    'meta': {
        'timestamp': int,
        'module': str,
        'version': str
    }
}
```

### 4. 统一入口实现
4.1 主控制器
- scripts/main_controller.py 重构为统一入口
- 协调各模块初始化和调用
- 管理模块生命周期
- 代码示例：
```python
#!/usr/bin/env python3
"""
脚本主控制器 - 统一入口
"""
import sys
import importlib
from pathlib import Path
from typing import Dict, List, Any

class ScriptController:
    """脚本主控制器"""
    
    def __init__(self):
        self.modules = {}
        self.config = {}
        self.status = 'initialized'
    
    def load_config(self, config_path: str) -> bool:
        """加载配置"""
        import json
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        return True
    
    def register_module(self, name: str, module_path: str) -> bool:
        """注册模块
        Args:
            name: 模块名称
            module_path: 模块路径
        Returns:
            bool: 注册是否成功
        """
        module = importlib.import_module(module_path)
        self.modules[name] = module
        return True
    
    def init_all(self) -> bool:
        """初始化所有模块"""
        for name, module in self.modules.items():
            if hasattr(module, 'init'):
                config = self.config.get(name, {})
                if not module.init(config):
                    return False
        return True
    
    def execute(self, module_name: str, method: str, data: dict = None) -> dict:
        """执行模块方法
        Args:
            module_name: 模块名称
            method: 方法名称
            data: 输入数据
        Returns:
            dict: 执行结果
        """
        if module_name not in self.modules:
            return {'status': 'error', 'error': {'message': f'Module {module_name} not found'}}
        
        module = self.modules[module_name]
        method_func = getattr(module, method, None)
        
        if not method_func:
            return {'status': 'error', 'error': {'message': f'Method {method} not found'}}
        
        try:
            if data:
                result = method_func(data)
            else:
                result = method_func()
            return {'status': 'success', 'data': result}
        except Exception as e:
            return {'status': 'error', 'error': {'message': str(e)}}
    
    def destroy_all(self) -> bool:
        """销毁所有模块"""
        for name, module in self.modules.items():
            if hasattr(module, 'destroy'):
                module.destroy()
        return True

def main():
    """主入口"""
    controller = ScriptController()
    controller.load_config('scripts_config.json')
    
    # 注册模块
    controller.register_module('health', 'scripts.health.check_coordinator')
    controller.register_module('deploy', 'scripts.deploy.deploy_coordinator')
    controller.register_module('verify', 'scripts.utils.verify_coordinator')
    
    # 初始化
    if not controller.init_all():
        print("Module initialization failed")
        sys.exit(1)
    
    # 执行命令
    if len(sys.argv) > 1:
        command = sys.argv[1]
        if command == 'health':
            result = controller.execute('health', 'check_all')
        elif command == 'deploy':
            result = controller.execute('deploy', 'run')
        elif command == 'verify':
            result = controller.execute('verify', 'check')
        else:
            result = {'status': 'error', 'error': {'message': f'Unknown command: {command}'}}
        
        print(result)
    
    # 清理
    controller.destroy_all()

if __name__ == '__main__':
    main()
```

### 5. 脚本合并策略
5.1 识别重复功能
- 检查相同名称的函数
- 检查功能相似的脚本
- 标记需要合并的脚本

5.2 合并实施
- 保留最符合架构设计的实现
- 合并相似功能
- 确保接口契约不被破坏
- 删除冗余脚本

### 6. 跨域与接口设计
6.1 CORS配置
- Web界面需要处理跨域问题
- 后端API需要配置CORS
- 代码示例：
```python
# scripts/web/cors_config.py
from fastapi.middleware.cors import CORSMiddleware

def setup_cors(app):
    """设置CORS"""
    origins = [
        "http://localhost",
        "http://localhost:8080",
        "http://127.0.0.1:8080",
    ]
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
```

6.2 接口设计规范
- RESTful API 设计
- 统一响应格式
- 版本控制
- 代码示例：
```python
# scripts/web/api_response.py
from typing import Any, Dict
from pydantic import BaseModel

class APIResponse(BaseModel):
    """API响应标准格式"""
    status: str = 'success'
    data: Any = None
    error: Dict = None
    meta: Dict = {
        'timestamp': 0,
        'version': '1.0'
    }

def success_response(data: Any) -> Dict:
    """成功响应"""
    return {
        'status': 'success',
        'data': data,
        'error': None,
        'meta': {
            'timestamp': int(time.time()),
            'version': '1.0'
        }
    }

def error_response(message: str, code: int = 400) -> Dict:
    """错误响应"""
    return {
        'status': 'error',
        'data': None,
        'error': {
            'code': code,
            'message': message
        },
        'meta': {
            'timestamp': int(time.time()),
            'version': '1.0'
        }
    }
```

### 7. 模板与动态渲染
7.1 模板引擎配置
- 使用Jinja2模板引擎
- 支持动态数据绑定
- 代码示例：
```python
# scripts/web/template_manager.py
from jinja2 import Environment, FileSystemLoader
from pathlib import Path

class TemplateManager:
    """模板管理器"""
    
    def __init__(self, template_dir: str):
        self.template_dir = Path(template_dir)
        self.env = Environment(loader=FileSystemLoader(str(template_dir)))
    
    def render(self, template_name: str, context: dict) -> str:
        """渲染模板
        Args:
            template_name: 模板名称
            context: 上下文数据
        Returns:
            str: 渲染后的HTML
        """
        template = self.env.get_template(template_name)
        return template.render(**context)
```

### 8. 事件处理与防抖
8.1 事件冒泡处理
- 在嵌套弹窗中防止事件冒泡
- 避免关闭按钮触发父弹窗事件
- 代码示例：
```javascript
// scripts/ui/event-handler.js
class EventHandler {
    constructor() {
        this.eventMap = new Map();
    }
    
    bindEvent(element, eventType, handler, useCapture = false) {
        element.addEventListener(eventType, (e) => {
            e.stopPropagation();
            handler(e);
        }, useCapture);
    }
    
    bindModalEvents(modalElement) {
        // 绑定关闭按钮
        const closeBtn = modalElement.querySelector('.close-button');
        if (closeBtn) {
            this.bindEvent(closeBtn, 'click', () => {
                this.closeModal(modalElement);
            });
        }
        
        // 绑定背景点击
        this.bindEvent(modalElement, 'click', (e) => {
            if (e.target === modalElement) {
                this.closeModal(modalElement);
            }
        });
    }
    
    closeModal(modalElement) {
        modalElement.classList.remove('show');
        // 清理资源
        this.cleanupModal(modalElement);
    }
    
    cleanupModal(modalElement) {
        // 清理事件监听
        // 清理定时器
        // 清理DOM
    }
}
```

### 9. 缓存管理
9.1 缓存清理策略
- 定期清理无用缓存
- 防止缓存冲突
- 代码示例：
```python
# scripts/utils/cache_manager.py
import os
import time
from pathlib import Path

class CacheManager:
    """缓存管理器"""
    
    def __init__(self, cache_dir: str, max_age: int = 86400):
        self.cache_dir = Path(cache_dir)
        self.max_age = max_age  # 24小时
    
    def clean_old_cache(self):
        """清理过期缓存"""
        current_time = time.time()
        for cache_file in self.cache_dir.rglob('*'):
            if cache_file.is_file():
                file_mtime = cache_file.stat().st_mtime
                if current_time - file_mtime > self.max_age:
                    cache_file.unlink()
    
    def check_cache_conflicts(self):
        """检查缓存冲突"""
        # 实现冲突检测逻辑
        pass
    
    def optimize_cache(self):
        """优化缓存"""
        self.clean_old_cache()
        self.check_cache_conflicts()
```

## 依赖关系
- 脚本扫描依赖文件读取
- 脚本拆分依赖扫描结果
- 接口标准化独立进行
- 统一入口依赖各模块

## 联动检查点
- 修改脚本拆分 → 检查依赖关系
- 修改接口标准 → 检查所有模块
- 修改统一入口 → 检查调用关系

## 测试验证
- 脚本扫描准确
- 脚本拆分正确
- 接口标准化有效
- 统一入口调用正常

## 验收标准
- 每个脚本单一职责
- 模块接口标准化
- 统一入口协调调用
- 无功能重叠
- 无隐式依赖

