# 22. 自动化部署脚本重构任务

## 任务概述
根据 docs/待部署内容/1.自动化部署脚本的设计与开发大纲.txt、docs/待部署内容/2.编程交付前全局注意事项.txt、docs/待部署内容/3.项目层级蓝图.txt、docs/待部署内容/4,项目全局核心结构逻辑.txt、docs/待部署内容/5.逻辑性项目思路扩展.txt、docs/待部署内容/6.落实代码需要优化的部分问题.txt 中的详细描述，对 scripts/ 文件夹进行彻底重构，实现高内聚、低耦合、模块化设计。每个脚本职责单一，统一入口调用。

## 模块职责
- **环境检测模块**: 仅负责检测Python版本、依赖、系统要求。不执行安装。
- **依赖管理模块**: 仅负责安装和验证依赖包。不检测环境。
- **配置验证模块**: 仅验证配置文件一致性。不修改配置。
- **部署执行模块**: 仅执行部署步骤。不检测环境。
- **监控模块**: 仅监控系统状态。不执行部署。
- **统一入口**: 调用各模块，协调执行顺序。

## 详细部署说明

### 1. 脚本拆分
1.1 现有脚本分析
- scripts/deploy.sh: 部署主脚本，需要拆分
- scripts/health_check.py: 健康检查，需要模块化
- scripts/start_health_monitor.py: 启动监控，需要重构
- scripts/start_backend_simple.py: 后端启动，需要拆分
- scripts/start_gui_py.py: GUI启动，需要拆分
- scripts/verify_paths.py: 路径验证，需要模块化
- scripts/validate_configs.py: 配置验证，需要模块化
- scripts/path_config.py: 路径配置，需要模块化
- scripts/entry.py: 入口文件，需要重构
- scripts/main_controller.py: 主控制器，需要重构

1.2 拆分策略
- 每个脚本按功能拆分为独立模块
- 每个模块实现单一职责接口
- 模块间通过标准API通信
- 统一入口协调调用

### 2. 统一入口实现
2.1 deploy.py 主入口
- 创建 `scripts/deploy.py` 作为主入口
- 支持命令行参数控制执行流程
- 按依赖顺序调用各模块
- 代码示例：
```python
#!/usr/bin/env python3
"""
自动化部署脚本主入口
"""
import argparse
import sys
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

def main():
    parser = argparse.ArgumentParser(description='自动化部署脚本')
    parser.add_argument('--env', choices=['dev', 'test', 'prod'], default='dev', help='部署环境')
    parser.add_argument('--step', choices=['all', 'check', 'install', 'deploy', 'verify'], default='all', help='执行步骤')
    parser.add_argument('--dry-run', action='store_true', help='演练模式')
    args = parser.parse_args()
    
    # 根据参数执行相应步骤
    if args.step == 'all':
        execute_all_steps(args)
    else:
        execute_single_step(args.step, args)

def execute_all_steps(args):
    """执行所有步骤"""
    steps = ['check', 'install', 'deploy', 'verify']
    for step in steps:
        execute_single_step(step, args)

def execute_single_step(step, args):
    """执行单个步骤"""
    step_modules = {
        'check': 'scripts.core.check',
        'install': 'scripts.core.install',
        'deploy': 'scripts.core.deploy',
        'verify': 'scripts.core.verify'
    }
    module_name = step_modules.get(step)
    if module_name:
        importlib.import_module(module_name).execute(args)

if __name__ == '__main__':
    main()
```

### 3. 环境适配
3.1 操作系统检测
- 检测操作系统类型（Windows/Linux/macOS）
- 适配路径分隔符和权限
- 支持多平台兼容
- 代码示例：
```python
import platform
import os

class EnvironmentDetector:
    """环境检测器"""
    
    @staticmethod
    def get_os_type():
        """获取操作系统类型"""
        system = platform.system().lower()
        if system == 'windows':
            return 'windows'
        elif system == 'linux':
            return 'linux'
        elif system == 'darwin':
            return 'macos'
        return 'unknown'
    
    @staticmethod
    def get_path_separator():
        """获取路径分隔符"""
        return os.sep
    
    @staticmethod
    def check_admin权限(self):
        """检查管理员权限"""
        if platform.system() == 'Windows':
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:
            return os.geteuid() == 0
```

3.2 Python版本检测
- 检测Python版本（3.10-3.11推荐）
- 验证必要的Python模块
- 检查虚拟环境

### 4. 依赖管理
4.1 依赖检查
- 读取 requirements.txt
- 检查已安装的包版本
- 标记缺失或版本不匹配的依赖
- 代码示例：
```python
class DependencyManager:
    """依赖管理器"""
    
    def __init__(self, requirements_file):
        self.requirements_file = requirements_file
        self.installed_packages = {}
    
    def load_requirements(self):
        """加载依赖列表"""
        with open(self.requirements_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    # 解析依赖行
                    name, version = self._parse_requirement(line)
                    self.requirements[name] = version
    
    def check_installed(self):
        """检查已安装的包"""
        import pkg_resources
        for dist in pkg_resources.working_set:
            self.installed_packages[dist.project_name] = dist.version
    
    def find_missing(self):
        """找出缺失的依赖"""
        missing = []
        for name, version in self.requirements.items():
            if name not in self.installed_packages:
                missing.append((name, version))
            elif version and not self._version_match(self.installed_packages[name], version):
                missing.append((name, version))
        return missing
```

4.2 版本锁定和兼容性检查
- 使用 pip-tools 或 poetry 管理依赖
- 生成 constraints 文件
- 检查版本兼容性

4.3 自动安装
- 静默模式安装依赖
- 处理安装错误
- 验证安装结果

### 5. 安全与权限
5.1 权限检查和提升
- 检查必要权限
- 提示权限提升
- 记录权限变更
- 代码示例：
```python
class PermissionManager:
    """权限管理器"""
    
    def __init__(self):
        self.detector = EnvironmentDetector()
    
    def check_required_permissions(self):
        """检查所需权限"""
        required = []
        if not self.detector.check_admin权限():
            required.append('管理员权限')
        return required
    
    def request_elevation(self):
        """请求权限提升"""
        if self.detector.get_os_type() == 'windows':
            import ctypes
            ctypes.windll.shell32.ShellExecuteW(
                None, "runas", sys.executable, " ".join(sys.argv), None, 1
            )
```

5.2 敏感信息加密存储
- 使用环境变量存储敏感信息
- 加密配置文件
- 审计日志记录

### 6. 错误处理
6.1 全局异常捕获
- 设置全局异常处理器
- 记录详细错误信息
- 提供友好的错误提示
- 代码示例：
```python
import logging
import traceback
import sys

class ErrorHandler:
    """错误处理器"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def setup_global_handler(self):
        """设置全局异常捕获"""
        sys.excepthook = self.handle_exception
    
    def handle_exception(self, exc_type, exc_value, exc_traceback):
        """处理异常"""
        self.logger.error(
            "Uncaught exception",
            exc_info=(exc_type, exc_value, exc_traceback)
        )
        # 清理操作
        self.cleanup()
        # 退出
        sys.exit(1)
    
    def cleanup(self):
        """清理操作"""
        # 释放锁
        # 关闭文件
        # 清理临时文件
```

6.2 重试机制实现
- 指数退避重试
- 最大重试次数
- 记录重试日志

6.3 回滚策略
- 备份配置文件
- 回滚依赖安装
- 回滚文件修改

### 7. 监控与日志
7.1 统一日志格式
- 定义日志格式
- 设置日志级别
- 支持日志轮转
- 代码示例：
```python
import logging
import logging.handlers
from datetime import datetime

class LogManager:
    """日志管理器"""
    
    def __init__(self, log_dir):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def setup_logger(self, name, level=logging.INFO):
        """设置日志记录器"""
        logger = logging.getLogger(name)
        logger.setLevel(level)
        
        # 文件处理器
        log_file = self.log_dir / f"{name}_{datetime.now().strftime('%Y%m%d')}.log"
        file_handler = logging.handlers.RotatingFileHandler(
            log_file, maxBytes=10*1024*1024, backupCount=5, encoding='utf-8'
        )
        file_handler.setFormatter(self._get_formatter())
        
        # 控制台处理器
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(self._get_formatter())
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger
    
    def _get_formatter(self):
        """获取日志格式"""
        return logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
```

7.2 实时状态监控
- 监控服务状态
- 监控资源使用
- 发送告警通知

7.3 部署进度跟踪
- 记录部署步骤
- 显示进度百分比
- 保存部署报告

### 8. 跨平台支持
8.1 Windows 平台
- 使用 batch 脚本辅助
- 处理路径差异
- 处理权限差异

8.2 Linux 平台
- 使用 shell 脚本辅助
- 处理 systemd 服务
- 处理权限差异

8.3 macOS 平台
- 处理 brew 依赖
- 处理签名问题
- 处理权限差异

### 9. 幂等性保证
- 重复执行不产生副作用
- 使用检查-执行模式
- 记录执行状态

### 10. 测试验证
- 各模块独立测试
- 集成测试
- 跨平台测试
- 错误场景测试

## 依赖关系
- 各模块独立，无隐式依赖
- 通过配置文件共享状态
- 统一入口协调调用

## 联动检查点
- 修改部署脚本 → 检查 scripts_config.json
- 修改环境检测 → 检查 requirements.txt
- 修改权限处理 → 检查系统兼容性

## 测试验证
- 各模块独立测试通过
- 统一入口调用正常
- 跨平台兼容性验证
- 错误场景处理正确

## 验收标准
- 脚本模块化，高内聚低耦合
- 统一入口调用所有功能
- 无功能重叠或隐式依赖
- 支持完整部署流程
- 跨平台兼容
- 错误处理完善

